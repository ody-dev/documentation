{"/docs/installation/":{"data":{"":"","quickstart#Quickstart":"The fastest way to get up and running is by installing a skeleton project. This bootstraps all the required components and installs Eloquent and Swoole components.\ncreate-project ody/ody-skel ody cp .env.example .env By default, a UserController, User model and UserRepository is provided with basic crud methods. Set up your DB credentials in .env and create a users table. This can be done through migrations, to create your first migration run:\nphp ody migrations:create UsersTable --config config/database.php The migration file is created in the folder database\\migrations. docs\n\u003c?php declare(strict_types=1); use Ody\\DB\\Migrations\\Migration\\AbstractMigration; final class UsersTable extends AbstractMigration { protected function up(): void { // add this to the generated migrations $this-\u003etable('users') -\u003eaddColumn('first_name', 'string') -\u003eaddColumn('last_name', 'string') -\u003eaddColumn('password', 'string') -\u003eaddColumn('email', 'integer') -\u003eaddColumn('created_at', 'datetime') -\u003eaddColumn('updated_at', 'datetime') -\u003eaddIndex('email', Index::TYPE_UNIQUE) -\u003ecreate(); } protected function down(): void { $this-\u003etable('users') -\u003edrop(); } } Finally run the migration.\nphp ody migrations:run Start the app and create a user.\nphp ody server:start -p // the -p flag starts a regular built-in php server POST http://localhost:9501/users Content-Type: application/json { \"first_name\": \"John\", \"last_name\": \"Doe\", \"email\": \"john@mail.com\", \"password\": \"asupersecurepassword\" } GET http://localhost:9501/users/1 "},"title":"Installation"},"/docs/server/http_server/":{"data":{"":"","installation#Installation":" composer install ody/http-server Configuration Create a config/server.php file and add the following content:\nreturn [ 'mode' =\u003e SWOOLE_BASE, 'host' =\u003e env('HTTP_SERVER_HOST' , '127.0.0.1'), 'port' =\u003e env('HTTP_SERVER_PORT' , 9501) , 'sock_type' =\u003e SWOOLE_SOCK_TCP, 'additional' =\u003e [ 'worker_num' =\u003e env('HTTP_SERVER_WORKER_COUNT' , swoole_cpu_num() * 2) , /* * log level * SWOOLE_LOG_DEBUG (default) * SWOOLE_LOG_TRACE * SWOOLE_LOG_INFO * SWOOLE_LOG_NOTICE * SWOOLE_LOG_WARNING * SWOOLE_LOG_ERROR */ 'log_level' =\u003e SWOOLE_LOG_DEBUG , 'log_file' =\u003e storagePath('logs/ody_server.log') , 'open_http_protocol' =\u003e true, 'enable_coroutine' =\u003e false ], 'ssl' =\u003e [ 'ssl_cert_file' =\u003e null , 'ssl_key_file' =\u003e null , ] , /* * Files and folders that must be watched in real time */ 'watcher' =\u003e [ 'App', 'config', 'database', 'composer.lock', '.env', ] ]; Starting the web server php ody server:start [-d|run as daemon] [-w|eable a watcher] ","introduction#Introduction":"This package requires ext-swoole to be installed on your system."},"title":"HTTP Server"},"/docs/server/websocket_server/":{"data":{"":"","installation#Installation":" composer install ody/websocket-server Configuration Create a config/websockets.php file and add the following content:\n\u003c?php use Ody\\Swoole\\Event; return [ 'host' =\u003e env('WEBSOCKET_HOST', '127.0.0.1'), 'port' =\u003e env('WEBSOCKET_PORT', 9502), 'sock_type' =\u003e SWOOLE_SOCK_TCP, 'callbacks' =\u003e [ Event::ON_HAND_SHAKE =\u003e [\\Ody\\Websocket\\Server::class, 'onHandShake'], Event::ON_MESSAGE =\u003e [\\Ody\\Websocket\\Server::class, 'onMessage'], Event::ON_CLOSE =\u003e [\\Ody\\Websocket\\Server::class, 'onClose'], Event::ON_REQUEST =\u003e [\\Ody\\Websocket\\Server::class, 'onRequest'], Event::ON_DISCONNECT =\u003e [\\Ody\\Websocket\\Server::class, 'onDisconnect'], ], 'secret_key' =\u003e env('WEBSOCKET_SECRET_KEY', '123123123'), \"additional\" =\u003e [ \"worker_num\" =\u003e env('WEBSOCKET_WORKER_COUNT', swoole_cpu_num() * 2), /* * log level * SWOOLE_LOG_DEBUG (default) * SWOOLE_LOG_TRACE * SWOOLE_LOG_INFO * SWOOLE_LOG_NOTICE * SWOOLE_LOG_WARNING * SWOOLE_LOG_ERROR */ 'log_level' =\u003e SWOOLE_LOG_DEBUG , 'log_file' =\u003e storagePath('logs/ody_websockets.log') , ] ]; Edit your .env file.\nWEBSOCKET_HOST=127.0.0.1 WEBSOCKET_PORT=9502 WEBSOCKET_SECRET_KEY=123123123 WEBSOCKET_WORKER_COUNT=8 Middleware WIP\nHandling regular HTTP requests In addition to separating HTTP services and WebSocket services through ports, we can also listen for HTTP requests in a WebSocket server. Http requests get send to the Event::onRequest callback.","introduction#Introduction":"The current implementation of a websocket server is still in it’s early stages. Donwload the composer package and edit the config file or add env variables in your .env file.\nThis package requires ext-swoole to be installed on your system.","usage#Usage":"Starting a websocket server To run a websocket server run the following command:\nphp ody websocket start This command accepts a -d flag, when enabled the server runs as a daemon.\nphp ody websocket:reload php ody sebsocket:stop Websocket callbacks Out of the box the websocket listens for the following events:\nonHandshake onMessage onClose onRequest onDisconnect onOpen These are mapped to a basic implementation of a websocket server. They can accept messages, send messages,…\nYou can override these native callbacks by creating a WebsocketController and configuring the methods in the callback[] section of the config file.\nA very basic implementation of a WebsocketController.php looks like this:\n\u003c?php declare(strict_types=1); namespace App\\Http\\Controllers; use Swoole\\Http\\Request; use Swoole\\Server; use Swoole\\Websocket\\Frame; use Swoole\\WebSocket\\Server as WsServer; class WebSocketController { public function onRequest(Request $request, Response $response): void { // Handle a regular http request. } public function onHandshake(Request $request, Response $response): void { $server-\u003epush($frame-\u003efd, 'Recv: ' . $frame-\u003edata); } public function onMessage(WsServer $server, Frame $frame): void { $server-\u003epush($frame-\u003efd, 'Recv: ' . $frame-\u003edata); } public function onClose(WsServer $server, int $fd, int $reactorId): void { var_dump('closed'); } public function onOpen(WsServer $server, Request $request): void { $server-\u003epush($request-\u003efd, 'Opened'); } public static function onDisconnect(WsServer $server, int $fd): void { // } } Callbacks for WebSocket servers are not triggered in the same coroutine, so that they cannot directly use the stored information of context. A context manager is provided by WebSocket Server component. On boot the server can be accessed through ContextManager::get('WsServer'). This can be usefull to push to websocket clients for example in methods where no server property is accessible\nExample:\n/* * Loop through all the WebSocket connections to * send back a response to all clients. Broadcast * a message back to every WebSocket client. */ public static function onRequest(Request $request, Response $response): void { $server = ContextManager::get('WsServer'); foreach($server-\u003econnections as $fd) { // Validate a correct WebSocket connection otherwise a push may fail if($server-\u003eisEstablished($fd)) { $clientName = sprintf(\"Client-%'.06d\\n\", $fd); echo \"Pushing event to $clientName...\\n\"; $server-\u003epush($fd, $request-\u003egetContent()); } } $response-\u003estatus(200); $response-\u003eend(); } Keeping track of connections On boot an in memory table is created to keep track of active connections.\n// Register a client $table = ContextManager::get('FdsTable'); $table-\u003e$fds-\u003eset((string) $fd, [ 'fd' =\u003e $fd, 'name' =\u003e sprintf($clientName) ]); echo \"Connection \u003c{$fd}\u003e open by {$clientName}. Total connections: \" . static::$fds-\u003ecount() . \"\\n\"; // Look up a client $sender = $table-\u003efds-\u003eget(strval($frame-\u003efd), \"name\"); echo \"Received from \" . $sender . \", message: {$frame-\u003edata}\" . PHP_EOL; // Delete a client $table-\u003efds-\u003edel((string) $fd); "},"title":"Websocket Server"}}