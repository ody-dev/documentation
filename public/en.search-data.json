{"/docs/architecture/lifecycle/":{"data":{"":"ODY has two modes of operation; It can be run as a regular PHP application like we are used to, or it can run on a coroutine based server developed on top of Swoole. To understand the lifecycle of a coroutine based application a good understanding of Swoole is required.\nBoth modes share the same application core components. (see section foundation) While developing ODY we stived to keep things as clear and familiar as possible to make development as easy as possible if you are already accustomed to frameworks like Laravel and Symfony.","coroutines#Coroutines":"What are coroutines? Coroutines effectively solve the challenge of asynchronous non-blocking systems, but what exactly are they?\nBy definition, coroutines are lightweight threads managed by user code rather than the OS kernel, meaning the user controls execution switches instead of the OS allocating CPU time. In Swoole, each Worker process has a coroutine scheduler that switches execution when an I/O operation occurs or when explicitly triggered. Since a process runs coroutines one at a time, there’s no need for synchronization locks like in multi-threaded programming.\nWithin a coroutine, execution remains sequential. In an HTTP coroutine server, each request runs in its own coroutine. For example, if coroutine A handles request A and coroutine B handles request B, execution switches when coroutine A encounters an I/O operation (e.g., a MySQL query). While coroutine A waits for the database response, coroutine B executes. Once the I/O completes, execution returns to coroutine A, ensuring non-blocking execution.\nHowever, to enable coroutine switching, operations like MySQL queries must be asynchronous and non-blocking—otherwise, the scheduler cannot switch coroutines, causing blocking, which defeats the purpose of coroutine-based programming.\nThe lifecycle of coroutines Because ODY uses an asynchronous, event-driven architecture, it avoids the overhead of traditional PHP-FPM request lifecycle, making it ideal for high-performance applications. ODY’s coroutines implementation allows for non-blocking I/O while maintaining a synchronous-like coding style.\nIn ODY, the request/response lifecycle follows an event-driven, coroutine-based model designed for high-performance asynchronous processing. Here’s a high-level overview:\nServer Initialization\nA Swoole HTTP/TCP/WebSocket server starts and listens for incoming connections. It runs as a long-lived process with worker and event loops. Handling Incoming Requests\nWhen a client sends a request, Swoole’s event loop accepts it without blocking. The request data (headers, body, etc.) is parsed and passed to the registered request handler. Processing the Request\nBusiness logic executes inside a worker coroutine. Swoole supports non-blocking I/O (e.g., MySQL, Redis, HTTP requests) via coroutines for high concurrency. Custom middleware, routing, and controllers process the request. Generating and Sending the Response\nThe handler constructs an HTTP response. The response is sent back to the client via Swoole\\Http\\Response-\u003eend(). Connection Management\nAfter responding, the connection may be closed or kept alive depending on headers (e.g., Connection: keep-alive). Swoole reuses worker processes for handling new requests without restarting. How Coroutines Work When a coroutine performs an I/O operation (e.g., MySQL query, HTTP request), it yields execution. The event loop switches to another coroutine instead of blocking. Once the I/O operation completes, the coroutine resumes execution.\nExample: Coroutine-based MySQL Query\nInstead of using PDO (which is blocking), Swoole provides Swoole\\Coroutine\\MySQL:\nSwoole\\Coroutine\\run(function() { $mysql = new Swoole\\Coroutine\\MySQL(); $mysql-\u003econnect([ 'host' =\u003e '127.0.0.1', 'user' =\u003e 'root', 'password' =\u003e 'password', 'database' =\u003e 'test' ]); $result = $mysql-\u003equery(\"SELECT * FROM users\"); print_r($result); }); This executes without blocking the entire process.\nMiddleware Handling in ODY Swoole doesn’t have built-in middleware like traditional frameworks (Laravel, Symfony), but we have developed a kernel that registers and executes middleware like we are used to. Middleware gets registered at the application’s boot time and gets executed at each request. Keep in mind that when using coroutines in middleware the events are non blocking."},"title":"Lifecycle"},"/docs/installation/":{"data":{"":"","quickstart#Quickstart":"The fastest way to get up and running is by installing a skeleton project. This bootstraps all the required components and installs Eloquent and Swoole components.\ncreate-project ody/ody-skel ody cp .env.example .env By default, a UserController, User model and UserRepository is provided with basic crud methods. Set up your DB credentials in .env and create a users table. This can be done through migrations, to create your first migration run:\nphp ody migrations:create UsersTable --config config/database.php The migration file is created in the folder database\\migrations. docs\n\u003c?php declare(strict_types=1); use Ody\\DB\\Migrations\\Migration\\AbstractMigration; final class UsersTable extends AbstractMigration { protected function up(): void { // add this to the generated migrations $this-\u003etable('users') -\u003eaddColumn('first_name', 'string') -\u003eaddColumn('last_name', 'string') -\u003eaddColumn('password', 'string') -\u003eaddColumn('email', 'integer') -\u003eaddColumn('created_at', 'datetime') -\u003eaddColumn('updated_at', 'datetime') -\u003eaddIndex('email', Index::TYPE_UNIQUE) -\u003ecreate(); } protected function down(): void { $this-\u003etable('users') -\u003edrop(); } } Finally run the migration.\nphp ody migrations:run Start the app and create a user.\nphp ody server:start -p // the -p flag starts a regular built-in php server POST http://localhost:9501/users Content-Type: application/json { \"first_name\": \"John\", \"last_name\": \"Doe\", \"email\": \"john@mail.com\", \"password\": \"asupersecurepassword\" } GET http://localhost:9501/users/1 "},"title":"Installation"},"/docs/server/http_server/":{"data":{"":"","installation#Installation":" composer install ody/http-server Configuration Create a config/server.php file and add the following content:\nreturn [ 'mode' =\u003e SWOOLE_BASE, 'host' =\u003e env('HTTP_SERVER_HOST' , '127.0.0.1'), 'port' =\u003e env('HTTP_SERVER_PORT' , 9501) , 'sock_type' =\u003e SWOOLE_SOCK_TCP, 'additional' =\u003e [ 'worker_num' =\u003e env('HTTP_SERVER_WORKER_COUNT' , swoole_cpu_num() * 2) , /* * log level * SWOOLE_LOG_DEBUG (default) * SWOOLE_LOG_TRACE * SWOOLE_LOG_INFO * SWOOLE_LOG_NOTICE * SWOOLE_LOG_WARNING * SWOOLE_LOG_ERROR */ 'log_level' =\u003e SWOOLE_LOG_DEBUG , 'log_file' =\u003e storagePath('logs/ody_server.log') , 'open_http_protocol' =\u003e true, 'enable_coroutine' =\u003e false ], 'ssl' =\u003e [ 'ssl_cert_file' =\u003e null , 'ssl_key_file' =\u003e null , ] , /* * Files and folders that must be watched in real time */ 'watcher' =\u003e [ 'App', 'config', 'database', 'composer.lock', '.env', ] ]; Starting the web server php ody server:start [-d|run as daemon] [-w|eable a watcher] ","introduction#Introduction":"This package requires ext-swoole to be installed on your system."},"title":"HTTP Server"},"/docs/server/websocket_server/":{"data":{"":"","installation#Installation":" composer install ody/websocket-server Configuration Create a config/websockets.php file and add the following content:\n\u003c?php use Ody\\Swoole\\Event; return [ 'host' =\u003e env('WEBSOCKET_HOST', '127.0.0.1'), 'port' =\u003e env('WEBSOCKET_PORT', 9502), 'sock_type' =\u003e SWOOLE_SOCK_TCP, 'callbacks' =\u003e [ Event::ON_HAND_SHAKE =\u003e [\\Ody\\Websocket\\Server::class, 'onHandShake'], Event::ON_MESSAGE =\u003e [\\Ody\\Websocket\\Server::class, 'onMessage'], Event::ON_CLOSE =\u003e [\\Ody\\Websocket\\Server::class, 'onClose'], Event::ON_REQUEST =\u003e [\\Ody\\Websocket\\Server::class, 'onRequest'], Event::ON_DISCONNECT =\u003e [\\Ody\\Websocket\\Server::class, 'onDisconnect'], ], 'secret_key' =\u003e env('WEBSOCKET_SECRET_KEY', '123123123'), \"additional\" =\u003e [ \"worker_num\" =\u003e env('WEBSOCKET_WORKER_COUNT', swoole_cpu_num() * 2), /* * log level * SWOOLE_LOG_DEBUG (default) * SWOOLE_LOG_TRACE * SWOOLE_LOG_INFO * SWOOLE_LOG_NOTICE * SWOOLE_LOG_WARNING * SWOOLE_LOG_ERROR */ 'log_level' =\u003e SWOOLE_LOG_DEBUG , 'log_file' =\u003e storagePath('logs/ody_websockets.log') , ] ]; Edit your .env file.\nWEBSOCKET_HOST=127.0.0.1 WEBSOCKET_PORT=9502 WEBSOCKET_SECRET_KEY=123123123 WEBSOCKET_WORKER_COUNT=8 Middleware WIP\nHandling regular HTTP requests In addition to handling WebSocket connections, the server can also process standard HTTP requests, making it a versatile solution for real-time applications. These requests are handled by the Event::onRequest callback, which allows developers to define custom logic for handling incoming HTTP traffic.\nBy leveraging this feature, you can serve both WebSocket and HTTP clients within the same application, reducing the need for separate infrastructure. This means that alongside real-time WebSocket communication, the server can manage tasks such as API requests, authentication, or even simple web page rendering, all within a single, unified system.","introduction#Introduction":"The WebSocket server implementation is still in its early stages, and new features are being actively developed. To get started, install the Composer package and configure the server by editing the config file or setting environment variables in your .env file. The configuration process is straightforward, allowing you to customize the WebSocket server to suit your application’s needs.\nThis package requires the ext-swoole extension to be installed on your system. Swoole provides high-performance, asynchronous networking capabilities, making it ideal for handling real-time WebSocket connections efficiently. Before proceeding, ensure that your system meets the necessary requirements for running Swoole and WebSockets.","usage#Usage":"Starting a websocket server To run a websocket server run the following command:\nphp ody websocket start This command accepts a -d flag, when enabled the server runs as a daemon.\nphp ody websocket:reload php ody sebsocket:stop Websocket callbacks By default, the WebSocket server listens for the following events:\nonHandshake - Triggered when a new WebSocket connection is being established. This event allows developers to customize the handshake process. onMessage - Fires when the server receives a message from a client. This is useful for processing incoming data and responding accordingly. onClose - Called when a WebSocket connection is closed. This allows for cleanup and resource management. onRequest - Handles incoming HTTP requests within the WebSocket server. This feature enables hybrid HTTP and WebSocket applications. onDisconnect - Triggered when a client disconnects from the server, allowing developers to track user sessions effectively. onOpen - Fired when a new WebSocket connection is successfully opened, enabling initial communication with the client. These events are mapped to basic WebSocket server implementations. You can override them by creating a WebSocketController and defining the methods in the callbacks[] section of the config file. Custom implementations give developers full control over WebSocket interactions, making it possible to build dynamic, event-driven applications with real-time communication capabilities.\n(Planned feature; Mapping the onRequest event to the application’s Http kernel)\nA very basic implementation of a WebsocketController.php:\n\u003c?php declare(strict_types=1); namespace App\\Http\\Controllers; use Swoole\\Http\\Request; use Swoole\\Server; use Swoole\\Websocket\\Frame; use Swoole\\WebSocket\\Server as WsServer; class WebSocketController { public function onRequest(Request $request, Response $response): void { // Handle a regular http request. } public function onHandshake(Request $request, Response $response): void { $server-\u003epush($frame-\u003efd, 'Recv: ' . $frame-\u003edata); } public function onMessage(WsServer $server, Frame $frame): void { $server-\u003epush($frame-\u003efd, 'Recv: ' . $frame-\u003edata); } public function onClose(WsServer $server, int $fd, int $reactorId): void { var_dump('closed'); } public function onOpen(WsServer $server, Request $request): void { $server-\u003epush($request-\u003efd, 'Opened'); } public static function onDisconnect(WsServer $server, int $fd): void { // } } Callbacks for WebSocket servers are not triggered in the same coroutine, so that they cannot directly use the stored information of context. A context manager is provided by WebSocket Server component. On boot the server can be accessed through ContextManager::get('WsServer'). This can be usefull to push to websocket clients for example in methods where no server property is accessible\nExample:\n/* * Loop through all the WebSocket connections to * send back a response to all clients. Broadcast * a message back to every WebSocket client. */ public static function onRequest(Request $request, Response $response): void { $server = ContextManager::get('WsServer'); foreach($server-\u003econnections as $fd) { // Validate a correct WebSocket connection otherwise a push may fail if($server-\u003eisEstablished($fd)) { $clientName = sprintf(\"Client-%'.06d\\n\", $fd); echo \"Pushing event to $clientName...\\n\"; $server-\u003epush($fd, $request-\u003egetContent()); } } $response-\u003estatus(200); $response-\u003eend(); } Keeping track of connections On boot an in memory table is created to keep track of active connections.\n// Register a client $table = ContextManager::get('FdsTable'); $table-\u003e$fds-\u003eset((string) $fd, [ 'fd' =\u003e $fd, 'name' =\u003e sprintf($clientName) ]); echo \"Connection \u003c{$fd}\u003e open by {$clientName}. Total connections: \" . static::$fds-\u003ecount() . \"\\n\"; // Look up a client $sender = $table-\u003efds-\u003eget(strval($frame-\u003efd), \"name\"); echo \"Received from \" . $sender . \", message: {$frame-\u003edata}\" . PHP_EOL; // Delete a client $table-\u003efds-\u003edel((string) $fd); "},"title":"Websocket Server"}}